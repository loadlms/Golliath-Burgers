// Sistema de banco de dados para Vercel com persist√™ncia em mem√≥ria global
const fs = require('fs');
const path = require('path');
const crypto = require('crypto');

// Fun√ß√£o para verificar se as credenciais do Supabase s√£o v√°lidas
function hasValidSupabaseCredentials() {
  const supabaseUrl = process.env.SUPABASE_URL;
  const supabaseKey = process.env.SUPABASE_ANON_KEY;
  
  // Debug das vari√°veis de ambiente
  console.log('üîç Debug Supabase Credentials:');
  console.log('SUPABASE_URL:', supabaseUrl ? `${supabaseUrl.substring(0, 30)}...` : 'undefined');
  console.log('SUPABASE_ANON_KEY:', supabaseKey ? `${supabaseKey.substring(0, 20)}...` : 'undefined');
  
  const isValid = supabaseUrl && 
         supabaseKey && 
         supabaseUrl !== 'your-supabase-url' && 
         supabaseKey !== 'your-supabase-anon-key' &&
         supabaseUrl.includes('supabase.co');
  
  console.log('‚úÖ Supabase credentials valid:', isValid);
  return isValid;
}

// Importa√ß√£o est√°tica do m√≥dulo Supabase
const supabaseModule = hasValidSupabaseCredentials() ? require('./supabase') : null;

const addCardapioItemInSupabase = supabaseModule?.addCardapioItemInSupabase || null;
const getCardapioFromSupabase = supabaseModule?.getCardapioFromSupabase || null;
const updateCardapioItemInSupabase = supabaseModule?.updateCardapioItemInSupabase || null;
const deleteCardapioItemInSupabase = supabaseModule?.deleteCardapioItemInSupabase || null;
const seedCardapioInSupabase = supabaseModule?.seedCardapioInSupabase || null;
const isSupabaseAvailable = supabaseModule?.isSupabaseAvailable || null;

console.log('üîç IMPORTA√á√ÉO SUPABASE - Credenciais v√°lidas:', hasValidSupabaseCredentials());
console.log('üîç IMPORTA√á√ÉO SUPABASE - M√≥dulo carregado:', !!supabaseModule);
console.log('üîç IMPORTA√á√ÉO SUPABASE - addCardapioItemInSupabase dispon√≠vel:', !!addCardapioItemInSupabase);
console.log('üîç IMPORTA√á√ÉO SUPABASE - Tipo da fun√ß√£o:', typeof addCardapioItemInSupabase);

// Caminho para o arquivo de dados (apenas para leitura inicial)
const DATA_FILE = path.join(process.cwd(), 'data', 'cardapio.json');

// Cache global compartilhado entre todas as inst√¢ncias
if (!global.cardapioData) {
  global.cardapioData = null;
  global.dataInitialized = false;
}

// Cache global para dados do card√°pio
let cardapioCache = {
    data: null,
    lastModified: 0,
    dataHash: null
};

// Fun√ß√£o para gerar hash dos dados
function generateDataHash(data) {
    const dataString = JSON.stringify(data.sort((a, b) => a.id - b.id));
    return crypto.createHash('md5').update(dataString).digest('hex');
}



// Fun√ß√£o para inicializar dados do arquivo
function initializeData() {
  if (global.dataInitialized) {
    return global.cardapioData;
  }
  
  try {
    // Primeiro, tentar carregar do arquivo cardapio.json original
    const originalCardapioPath = path.join(process.cwd(), 'data', 'cardapio.json');
    console.log('üîç Tentando carregar card√°pio de:', originalCardapioPath);
    
    if (fs.existsSync(originalCardapioPath)) {
      const fileData = fs.readFileSync(originalCardapioPath, 'utf8');
      const parsedData = JSON.parse(fileData);
      
      // Validar estrutura dos dados
      if (Array.isArray(parsedData) && parsedData.length > 0) {
        global.cardapioData = parsedData;
        console.log('üìÅ Dados carregados do card√°pio original - Total:', parsedData.length);
        global.dataInitialized = true;
        return global.cardapioData;
      }
    }
    
    console.log('‚ö†Ô∏è Arquivo cardapio.json n√£o encontrado ou inv√°lido, usando dados padr√£o');
    global.cardapioData = getDefaultData();
    global.dataInitialized = true;
    
  } catch (error) {
    console.error('‚ùå Erro ao carregar dados:', error.message);
    global.cardapioData = getDefaultData();
    global.dataInitialized = true;
    console.log('üîÑ Fallback para dados padr√£o devido ao erro');
  }
  
  return global.cardapioData;
}

// Fun√ß√£o para ler dados (com fallback para Supabase)
async function readData() {
    const startTime = Date.now();
    
    try {
        // Verificar se temos dados em cache v√°lidos
        if (cardapioCache.data && 
            cardapioCache.lastModified > Date.now() - 30000) { // Cache v√°lido por 30 segundos
            console.log('üìã Retornando dados do cache local');
            return cardapioCache.data;
        }

        console.log('üîÑ Cache expirado, buscando dados...');
        
        // Timeout para opera√ß√µes de banco
        const timeoutPromise = new Promise((_, reject) => {
            setTimeout(() => reject(new Error('Database timeout')), 10000);
        });
        
        // Tentar buscar do Supabase primeiro com timeout
        if (getCardapioFromSupabase) {
            try {
                console.log('üîç Buscando dados do Supabase...');
                const result = await Promise.race([
                    getCardapioFromSupabase(),
                    timeoutPromise
                ]);
                const supabaseData = result;
                
                if (supabaseData && Array.isArray(supabaseData) && supabaseData.length > 0) {
                    console.log(`‚úÖ Supabase: ${supabaseData.length} itens em ${Date.now() - startTime}ms`);
                    
                    // Atualizar cache
                    cardapioCache.data = supabaseData;
                    cardapioCache.lastModified = Date.now();
                    cardapioCache.dataHash = generateDataHash(supabaseData);
                    
                    return supabaseData;
                }
            } catch (supabaseError) {
                console.error('‚ö†Ô∏è Erro no Supabase:', supabaseError.message);
            }
        }
        
        // Fallback para dados locais
        console.log('üîÑ Fallback para dados locais...');
        const localData = initializeData();
        
        if (localData && Array.isArray(localData)) {
            cardapioCache.data = localData;
            cardapioCache.lastModified = Date.now();
            cardapioCache.dataHash = generateDataHash(localData);
            
            console.log(`üìÅ Dados locais: ${localData.length} itens`);
            return localData;
        }
        
        // √öltimo recurso: dados padr√£o
        console.log('üÜò Usando dados padr√£o');
        const defaultData = getDefaultData();
        cardapioCache.data = defaultData;
        cardapioCache.lastModified = Date.now();
        
        return defaultData;
        
    } catch (error) {
        console.error('‚ùå Erro cr√≠tico ao ler dados:', error.message);
        
        // Retornar cache antigo se dispon√≠vel
        if (cardapioCache.data) {
            console.log('üîÑ Retornando cache antigo devido ao erro');
            return cardapioCache.data;
        }
        
        // √öltimo recurso
        const defaultData = getDefaultData();
        cardapioCache.data = defaultData;
        return defaultData;
    }
}

// Fun√ß√£o para escrever dados (cache global e Supabase)
async function writeData(data) {
  try {
    // Tentar salvar no Supabase primeiro
    const supabaseAvailable = await isSupabaseAvailable();
    
    if (supabaseAvailable) {
      console.log('üåê Salvando dados no Supabase...');
      // Nota: Esta fun√ß√£o √© para salvar dados completos, mas o Supabase
      // ser√° atualizado item por item atrav√©s da fun√ß√£o updateCardapioItemInSupabase
      // Esta fun√ß√£o manter√° o cache atualizado
    }
    
    // Atualizar cache global
    global.cardapioData = data;
    global.dataInitialized = true;
    
    // Atualizar cache local com hash
    cardapioCache.data = data;
    cardapioCache.lastModified = Date.now();
    cardapioCache.dataHash = generateDataHash(data);
    
    console.log('üíæ Dados salvos no cache global (Vercel)');
    console.log('üìä Itens no cache:', data.length);
    
    return true;
  } catch (error) {
    console.error('‚ùå Erro ao salvar dados no cache:', error);
    return false;
  }
}

// Fun√ß√£o para obter dados padr√£o
function getDefaultData() {
  return [
    {
      "id": 1,
      "nome": "X BACON DE GOLIATH",
      "descricao": "Burger de 90g, com American Cheese, 2 fatias de bacon, molho especial de Golliath no p√£o brioche tostado na manteiga.",
      "preco": 24.90,
      "categoria": "hamburguers",
      "imagem": "https://ik.imagekit.io/golliathburgers/produtos/x-bacon-goliath.jpg",
      "disponivel": true,
      "destaque": true,
      "ordem": 1,
      "isActive": true,
      "createdAt": "2025-01-20T12:00:00.000Z",
      "updatedAt": "2025-01-20T12:00:00.000Z"
    },
    {
      "id": 2,
      "nome": "GOLLIATH TRIPLO P.C.Q",
      "descricao": "3x mais carne, 3x mais queijo. Com 3 Burguers de 90g totalizando 270g de carne, e com fatias de American Cheese, no p√£o brioche tostado na manteiga.",
      "preco": 32.90,
      "categoria": "hamburguers",
      "imagem": "https://ik.imagekit.io/golliathburgers/produtos/triplo-pcq.jpg",
      "disponivel": true,
      "destaque": true,
      "ordem": 2,
      "isActive": true,
      "createdAt": "2025-01-20T12:00:00.000Z",
      "updatedAt": "2025-01-20T12:00:00.000Z"
    },
    {
      "id": 3,
      "nome": "GOLLIATH TRIPLO BACON",
      "descricao": "3x mais carne, 3x mais queijo e 3x mais bacon. Com 3 Burguers de 90g totalizando 270g de carne, com fatias de American Cheese, 2 fatias de bacon por andar, e molho especial de Golliath no p√£o brioche tostado na manteiga.",
      "preco": 39.90,
      "categoria": "hamburguers",
      "imagem": "https://ik.imagekit.io/golliathburgers/produtos/triplo-bacon.jpg",
      "disponivel": true,
      "destaque": true,
      "ordem": 3,
      "isActive": true,
      "createdAt": "2025-01-20T12:00:00.000Z",
      "updatedAt": "2025-01-20T12:00:00.000Z"
    },
    {
      "id": 4,
      "nome": "GOLLIATH OKLAHOMA",
      "descricao": "4 burguers de 90g ao estilo Oklahoma, totalizando 360g de blend, com 4 fatias de queijo cheddar, no p√£o brioche selado na manteiga.",
      "preco": 49.90,
      "categoria": "hamburguers",
      "imagem": "https://ik.imagekit.io/golliathburgers/produtos/oklahoma.jpg",
      "disponivel": true,
      "destaque": true,
      "ordem": 4,
      "isActive": true,
      "createdAt": "2025-01-20T12:00:00.000Z",
      "updatedAt": "2025-01-20T12:00:00.000Z"
    }
  ];
}

// Fun√ß√£o para atualizar um item espec√≠fico (s√≠ncrona - apenas cache)
function updateItem(itemId, updates) {
  const data = readData();
  const itemIndex = data.findIndex(item => item.id === itemId);
  
  if (itemIndex === -1) {
    console.log(`Item com ID ${itemId} n√£o encontrado`);
    return false;
  }
  
  // Atualizar item
  data[itemIndex] = {
    ...data[itemIndex],
    ...updates,
    updatedAt: new Date().toISOString()
  };
  
  console.log(`Item ${itemId} atualizado:`, updates);
  return writeData(data);
}

// Fun√ß√£o para obter todos os dados
async function getAllData() {
  return await readData();
}

// Fun√ß√£o para resetar dados (√∫til para desenvolvimento)
function resetData() {
  global.cardapioData = getDefaultData();
  global.dataInitialized = true;
  console.log('Dados resetados para valores padr√£o');
  return true;
}

// Fun√ß√£o para obter hash atual dos dados
function getCurrentDataHash() {
    if (cardapioCache.dataHash) {
        return cardapioCache.dataHash;
    }
    
    // Se n√£o temos hash em cache, gerar a partir dos dados atuais
    const data = readData();
    if (data && data.length > 0) {
        cardapioCache.dataHash = generateDataHash(data);
        return cardapioCache.dataHash;
    }
    
    return null;
}

// Fun√ß√£o para atualizar item espec√≠fico (integra√ß√£o com Supabase)
async function updateItemAsync(id, updates) {
    // S√≥ tentar usar Supabase se as credenciais forem v√°lidas
    if (!hasValidSupabaseCredentials()) {
        console.log('‚ö†Ô∏è Credenciais do Supabase n√£o configuradas, usando apenas cache local');
        
        // Fallback: atualizar apenas no cache local
        if (cardapioCache.data) {
            const itemIndex = cardapioCache.data.findIndex(item => item.id === parseInt(id));
            if (itemIndex !== -1) {
                cardapioCache.data[itemIndex] = { ...cardapioCache.data[itemIndex], ...updates };
                cardapioCache.lastModified = Date.now();
                cardapioCache.dataHash = generateDataHash(cardapioCache.data);
                
                console.log(`üíæ Item ${id} atualizado no cache local`);
                return { success: true, data: cardapioCache.data[itemIndex] };
            }
        }
        
        return { success: true, message: 'Atualizado apenas no cache local' };
    }
    
    try {
        // Tentar atualizar no Supabase primeiro
        const supabaseAvailable = await isSupabaseAvailable();
        
        if (supabaseAvailable) {
            console.log(`üåê Atualizando item ${id} no Supabase...`);
            const result = await updateCardapioItemInSupabase(id, updates);
            
            if (result.success) {
                console.log(`‚úÖ Item ${id} atualizado no Supabase`);
                
                // Invalidar cache para for√ßar reload na pr√≥xima consulta
                cardapioCache.data = null;
                cardapioCache.lastModified = null;
                cardapioCache.dataHash = null;
                
                return { success: true, data: result.data };
            } else {
                console.error(`‚ùå Erro ao atualizar item ${id} no Supabase:`, result.error);
            }
        }
        
        // Fallback: atualizar apenas no cache local
        if (cardapioCache.data) {
            const itemIndex = cardapioCache.data.findIndex(item => item.id === parseInt(id));
            if (itemIndex !== -1) {
                cardapioCache.data[itemIndex] = { ...cardapioCache.data[itemIndex], ...updates };
                cardapioCache.lastModified = Date.now();
                cardapioCache.dataHash = generateDataHash(cardapioCache.data);
                
                console.log(`üíæ Item ${id} atualizado no cache local`);
                return { success: true, data: cardapioCache.data[itemIndex] };
            }
        }
        
        return { success: false, error: 'Item n√£o encontrado' };
    } catch (error) {
        console.error(`‚ùå Erro ao atualizar item ${id}:`, error);
        return { success: false, error: error.message };
    }
}

// Fun√ß√£o para obter dados do card√°pio (compatibilidade com API)
async function getCardapioData() {
  console.log('üìä getCardapioData chamada');
  const data = await readData();
  console.log('üìä Retornando', data.length, 'itens');
  return data;
}

// Fun√ß√£o para obter dados locais do card√°pio (fallback)
async function getLocalCardapioData() {
  console.log('üìã getLocalCardapioData chamada - retornando dados do cache/arquivo local');
  
  try {
    // Primeiro tentar cache em mem√≥ria
    if (global.cardapioData && global.dataInitialized) {
      console.log('üìä Retornando dados do cache global:', global.cardapioData.length, 'itens');
      return global.cardapioData;
    }
    
    // Se n√£o tem cache, tentar inicializar dados locais
    const localData = initializeData();
    if (localData && Array.isArray(localData)) {
      console.log('üìä Retornando dados inicializados:', localData.length, 'itens');
      return localData;
    }
    
    // √öltimo recurso: dados padr√£o
    console.log('üÜò Retornando dados padr√£o');
    return getDefaultData();
    
  } catch (error) {
    console.error('‚ùå Erro ao obter dados locais:', error.message);
    // Retornar dados padr√£o em caso de erro
    return getDefaultData();
  }
}

// Fun√ß√£o para atualizar item do card√°pio (compatibilidade com API)
async function updateCardapioItem(id, updates) {
  console.log('üîÑ updateCardapioItem chamada:', { id, updates });
  
  if (!global.cardapioData || !global.dataInitialized) {
    initializeData();
  }
  
  let itemIndex = global.cardapioData.findIndex(item => item.id === parseInt(id));
  
  // Se item n√£o encontrado no cache local, tentar buscar do Supabase
  if (itemIndex === -1 && hasValidSupabaseCredentials() && getCardapioFromSupabase) {
    console.log('üîç Item n√£o encontrado no cache local, buscando do Supabase:', id);
    try {
      const supabaseData = await getCardapioFromSupabase();
      if (supabaseData && supabaseData.length > 0) {
        console.log('üìä Dados do Supabase carregados:', supabaseData.length, 'itens');
        // Atualizar cache global com dados do Supabase
        global.cardapioData = supabaseData;
        cardapioCache.data = supabaseData;
        cardapioCache.lastModified = Date.now();
        cardapioCache.dataHash = generateDataHash(supabaseData);
        
        // Tentar encontrar o item novamente
        itemIndex = global.cardapioData.findIndex(item => item.id === parseInt(id));
        console.log('üîç Item encontrado ap√≥s sincroniza√ß√£o:', itemIndex !== -1);
      }
    } catch (error) {
      console.error('‚ùå Erro ao buscar dados do Supabase:', error.message);
    }
  }
  
  if (itemIndex === -1) {
    console.log('‚ùå Item n√£o encontrado nem no cache local nem no Supabase:', id);
    return { success: false, message: 'Item n√£o encontrado' };
  }
  
  const itemAntes = { ...global.cardapioData[itemIndex] };
  
  // Tentar usar Supabase primeiro
  console.log('üîç Verificando Supabase:', {
    hasCredentials: hasValidSupabaseCredentials(),
    hasFunction: !!updateCardapioItemInSupabase
  });
  
  if (hasValidSupabaseCredentials() && updateCardapioItemInSupabase) {
    try {
      console.log('üöÄ Tentando atualizar no Supabase:', { id, updates });
      const result = await updateCardapioItemInSupabase(id, updates);
      console.log('üìä Resultado do Supabase:', result);
      
      if (result.success) {
        // Atualizar cache local tamb√©m
        global.cardapioData[itemIndex] = {
          ...global.cardapioData[itemIndex],
          ...result.data,
          updatedAt: new Date().toISOString()
        };
        console.log('‚úÖ Item atualizado no Supabase e cache local');
        return { 
          success: true, 
          message: 'Item atualizado com sucesso',
          item: global.cardapioData[itemIndex]
        };
      } else {
        console.log('‚ùå Falha no Supabase:', result.error);
      }
    } catch (error) {
      console.log('‚ö†Ô∏è Erro no Supabase, usando cache local:', error.message);
    }
  } else {
    console.log('‚ö†Ô∏è Supabase n√£o dispon√≠vel, usando apenas cache local');
  }
  
  // Fallback para cache local
  global.cardapioData[itemIndex] = {
    ...global.cardapioData[itemIndex],
    ...updates,
    updatedAt: new Date().toISOString()
  };
  
  const itemDepois = { ...global.cardapioData[itemIndex] };
  console.log('‚úÖ Item atualizado no cache local:', { antes: itemAntes, depois: itemDepois });
  
  // NOTA: Vercel √© serverless - arquivos n√£o persistem entre execu√ß√µes
  console.log('‚ö†Ô∏è Ambiente serverless: dados salvos apenas em mem√≥ria durante esta execu√ß√£o');
  
  // Tentar salvar no arquivo JSON (funciona apenas localmente)
  try {
    const dataDir = path.join(process.cwd(), 'data');
    if (!fs.existsSync(dataDir)) {
      fs.mkdirSync(dataDir, { recursive: true });
    }
    fs.writeFileSync(DATA_FILE, JSON.stringify(global.cardapioData, null, 2));
    console.log('üíæ Dados salvos no arquivo JSON (apenas local)');
  } catch (error) {
    console.log('‚ö†Ô∏è N√£o foi poss√≠vel salvar no arquivo JSON:', error.message);
  }
  
  return { 
    success: true, 
    message: 'Item atualizado com sucesso',
    item: global.cardapioData[itemIndex]
  };
}

// Fun√ß√£o para adicionar item do card√°pio (compatibilidade com API)
async function addCardapioItem(itemData) {
  console.log('üÜï addCardapioItem chamada com dados:', itemData);
  
  if (!global.cardapioData || !global.dataInitialized) {
    console.log('üîÑ Inicializando dados...');
    initializeData();
  }
  
  console.log('üìä Estado atual do card√°pio:', global.cardapioData.length, 'itens');
  
  // Tentar usar Supabase primeiro
  console.log('üîç Verificando condi√ß√µes para usar Supabase:');
  console.log('  - hasValidSupabaseCredentials():', hasValidSupabaseCredentials());
  console.log('  - addCardapioItemInSupabase dispon√≠vel:', typeof addCardapioItemInSupabase);
  
  if (hasValidSupabaseCredentials() && addCardapioItemInSupabase) {
    try {
      console.log('üöÄ Tentando salvar no Supabase com dados:', JSON.stringify(itemData, null, 2));
      const result = await addCardapioItemInSupabase(itemData);
      console.log('üìä Resultado completo do Supabase:', JSON.stringify(result, null, 2));
      
      if (result.success) {
        // Atualizar cache local tamb√©m
        global.cardapioData.push(result.data);
        console.log('‚úÖ Item adicionado no Supabase e cache local');
        console.log('üìã Novo estado do card√°pio:', global.cardapioData.length, 'itens');
        console.log('üÜî ID do novo item:', result.data.id);
        return { success: true, message: 'Item adicionado com sucesso', data: { id: result.data.id, ...itemData } };
      } else {
        console.log('‚ùå Falha no Supabase:', result.error);
      }
    } catch (error) {
      console.log('‚ö†Ô∏è Erro no Supabase, usando cache local:', error.message);
      console.log('üìã Stack trace:', error.stack);
    }
  } else {
    console.log('‚ö†Ô∏è Condi√ß√µes n√£o atendidas para usar Supabase, usando cache local');
  }
  
  // Fallback para cache local
  const newId = Math.max(...global.cardapioData.map(item => item.id)) + 1;
  
  const newItem = {
    id: newId,
    ...itemData,
    createdAt: new Date().toISOString(),
    updatedAt: new Date().toISOString()
  };
  
  global.cardapioData.push(newItem);
  console.log('‚úÖ Novo item adicionado no cache local:', newItem);
  
  // NOTA: Vercel √© serverless - arquivos n√£o persistem entre execu√ß√µes
  console.log('‚ö†Ô∏è Ambiente serverless: dados salvos apenas em mem√≥ria durante esta execu√ß√£o');
  
  // Tentar salvar no arquivo JSON (funciona apenas localmente)
  try {
    const dataDir = path.join(process.cwd(), 'data');
    if (!fs.existsSync(dataDir)) {
      fs.mkdirSync(dataDir, { recursive: true });
    }
    fs.writeFileSync(DATA_FILE, JSON.stringify(global.cardapioData, null, 2));
    console.log('üíæ Dados salvos no arquivo JSON (apenas local)');
  } catch (error) {
    console.log('‚ö†Ô∏è N√£o foi poss√≠vel salvar no arquivo JSON:', error.message);
  }
  
  return { success: true, message: 'Item adicionado com sucesso', item: newItem };
}

// Fun√ß√£o para obter item espec√≠fico (compatibilidade com API)
function getCardapioItem(id) {
  if (!global.cardapioData || !global.dataInitialized) {
    initializeData();
  }
  
  const item = global.cardapioData.find(item => item.id === parseInt(id));
  
  if (!item) {
    return { success: false, message: 'Item n√£o encontrado' };
  }
  
  return { success: true, item };
}

// Fun√ß√£o para deletar item (compatibilidade com API)
async function deleteCardapioItem(id) {
  if (!global.cardapioData || !global.dataInitialized) {
    initializeData();
  }
  
  // Tentar usar Supabase primeiro
  if (hasValidSupabaseCredentials() && deleteCardapioItemInSupabase) {
    try {
      const result = await deleteCardapioItemInSupabase(id);
      if (result.success) {
        // Atualizar cache local tamb√©m
        const itemIndex = global.cardapioData.findIndex(item => item.id === parseInt(id));
        if (itemIndex !== -1) {
          global.cardapioData.splice(itemIndex, 1);
        }
        console.log('‚úÖ Item deletado do Supabase e cache local');
        return { success: true, message: 'Item deletado com sucesso' };
      }
    } catch (error) {
      console.log('‚ö†Ô∏è Erro no Supabase, usando cache local:', error.message);
    }
  }
  
  // Fallback para cache local
  const itemIndex = global.cardapioData.findIndex(item => item.id === parseInt(id));
  
  if (itemIndex === -1) {
    return { success: false, message: 'Item n√£o encontrado' };
  }
  
  // Marcar como inativo em vez de deletar
  global.cardapioData[itemIndex].isActive = false;
  global.cardapioData[itemIndex].updatedAt = new Date().toISOString();
  
  console.log('‚úÖ Item marcado como inativo no cache local:', global.cardapioData[itemIndex]);
  
  return { success: true, message: 'Item deletado com sucesso' };
}

// Fun√ß√£o para deletar item permanentemente (compatibilidade com API)
async function deleteCardapioItemPermanently(id) {
  console.log(`üóëÔ∏è deleteCardapioItemPermanently chamada para ID: ${id}`);
  
  // For√ßar sincroniza√ß√£o com Supabase primeiro
  console.log('üîÑ For√ßando sincroniza√ß√£o com Supabase...');
  cardapioCache.lastModified = 0; // For√ßa atualiza√ß√£o do cache
  
  try {
    const freshData = await readData();
    global.cardapioData = freshData;
    global.dataInitialized = true;
    console.log(`üìä Dados sincronizados: ${freshData.length} itens`);
  } catch (error) {
    console.error('‚ùå Erro ao sincronizar dados:', error);
    // Continua com dados locais se a sincroniza√ß√£o falhar
    if (!global.cardapioData || !global.dataInitialized) {
      console.log('üìÅ Inicializando dados locais...');
      initializeData();
    }
  }
  
  console.log(`üìä Total de itens no cache: ${global.cardapioData?.length || 0}`);
  console.log(`üîç Procurando item com ID: ${id} (tipo: ${typeof id})`);
  
  const itemIndex = global.cardapioData.findIndex(item => {
    console.log(`üîç Comparando: item.id=${item.id} (tipo: ${typeof item.id}) com id=${id} (tipo: ${typeof id})`);
    return item.id === parseInt(id);
  });
  
  console.log(`üìç Item encontrado no √≠ndice: ${itemIndex}`);
  
  if (itemIndex === -1) {
    console.log('‚ùå Item n√£o encontrado no cache local ap√≥s sincroniza√ß√£o');
    return { success: false, message: 'Item n√£o encontrado' };
  }
  
  const itemToDelete = global.cardapioData[itemIndex];
  console.log(`üéØ Item a ser deletado:`, itemToDelete);
  
  // Tentar deletar do Supabase primeiro
  console.log(`üîç Verificando fun√ß√£o deleteCardapioItemInSupabase: ${!!deleteCardapioItemInSupabase}`);
  if (deleteCardapioItemInSupabase) {
    try {
      console.log(`üöÄ Chamando deleteCardapioItemInSupabase para ID: ${id}`);
      const supabaseResult = await deleteCardapioItemInSupabase(id);
      console.log(`üìä Resultado do Supabase:`, supabaseResult);
      
      if (!supabaseResult.success) {
        console.error('‚ùå Erro ao deletar item do Supabase:', supabaseResult.error);
        // Continua com a exclus√£o local mesmo se o Supabase falhar
      } else {
        console.log('‚úÖ Item deletado do Supabase com sucesso');
      }
    } catch (error) {
      console.error('‚ùå Erro ao deletar item do Supabase:', error);
      // Continua com a exclus√£o local mesmo se o Supabase falhar
    }
  } else {
    console.log('‚ö†Ô∏è Fun√ß√£o deleteCardapioItemInSupabase n√£o dispon√≠vel');
  }
  
  const deletedItem = global.cardapioData.splice(itemIndex, 1)[0];
  console.log('‚úÖ Item deletado permanentemente do cache local:', deletedItem);
  console.log(`üìä Total de itens restantes no cache: ${global.cardapioData.length}`);
  
  return { success: true, message: 'Item deletado permanentemente', deletedItem };
}

module.exports = {
  readData: getAllData,
  writeData,
  updateItem,
  updateItemAsync,
  getDefaultData,
  resetData,
  getCurrentDataHash,
  getCardapioData,
  getLocalCardapioData,
  updateCardapioItem,
  addCardapioItem,
  getCardapioItem,
  deleteCardapioItem,
  deleteCardapioItemPermanently
};